import { __decorate, __param } from "tslib";
import { Directive, ElementRef, HostListener, Optional, Self } from '@angular/core';
import { CreditCard } from '../credit-card';
import { NgControl } from '@angular/forms';
let CvcFormatDirective = class CvcFormatDirective {
    constructor(el, control) {
        this.el = el;
        this.control = control;
        this.target = this.el.nativeElement;
    }
    /**
     * Updates the value to target element, or FormControl if exists.
     * @param value New input value.
     */
    updateValue(value) {
        if (this.control) {
            this.control.control.setValue(value);
        }
        else {
            this.target.value = value;
        }
    }
    onKeypress(e) {
        if (!CreditCard.restrictNumeric(e) && !CreditCard.restrictCvc(e.which, this.target)) {
            e.preventDefault();
        }
    }
    reformatCvc() {
        const val = CreditCard.replaceFullWidthChars(this.target.value)
            .replace(/\D/g, '')
            .slice(0, 4);
        const oldVal = this.target.value;
        if (val !== oldVal) {
            this.target.selectionStart = this.target.selectionEnd = CreditCard.safeVal(val, this.target, (safeVal => {
                this.updateValue(safeVal);
            }));
        }
    }
};
CvcFormatDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgControl, decorators: [{ type: Self }, { type: Optional }] }
];
__decorate([
    HostListener('keypress', ['$event'])
], CvcFormatDirective.prototype, "onKeypress", null);
__decorate([
    HostListener('paste'),
    HostListener('change'),
    HostListener('input')
], CvcFormatDirective.prototype, "reformatCvc", null);
CvcFormatDirective = __decorate([
    Directive({
        selector: 'input[ccCVC]',
    }),
    __param(1, Self()), __param(1, Optional())
], CvcFormatDirective);
export { CvcFormatDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3ZjLWZvcm1hdC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hbmd1bGFyLWNjLWxpYnJhcnkvIiwic291cmNlcyI6WyJsaWIvZGlyZWN0aXZlcy9jdmMtZm9ybWF0LmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDcEYsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzVDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUszQyxJQUFhLGtCQUFrQixHQUEvQixNQUFhLGtCQUFrQjtJQUc3QixZQUNVLEVBQWMsRUFDTSxPQUFrQjtRQUR0QyxPQUFFLEdBQUYsRUFBRSxDQUFZO1FBQ00sWUFBTyxHQUFQLE9BQU8sQ0FBVztRQUU5QyxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDO0lBQ3RDLENBQUM7SUFFRDs7O09BR0c7SUFDSyxXQUFXLENBQUMsS0FBYTtRQUMvQixJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDaEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ3RDO2FBQU07WUFDTCxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7U0FDM0I7SUFDSCxDQUFDO0lBR00sVUFBVSxDQUFDLENBQWdCO1FBQ2hDLElBQUksQ0FBQyxVQUFVLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUNuRixDQUFDLENBQUMsY0FBYyxFQUFFLENBQUM7U0FDcEI7SUFDSCxDQUFDO0lBS00sV0FBVztRQUNoQixNQUFNLEdBQUcsR0FBRyxVQUFVLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7YUFDNUQsT0FBTyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7YUFDbEIsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNmLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDO1FBQ2pDLElBQUksR0FBRyxLQUFLLE1BQU0sRUFBRTtZQUNsQixJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksR0FBRyxVQUFVLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUU7Z0JBQ3RHLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDNUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNMO0lBQ0gsQ0FBQztDQUNGLENBQUE7O1lBdkNlLFVBQVU7WUFDZSxTQUFTLHVCQUE3QyxJQUFJLFlBQUksUUFBUTs7QUFrQm5CO0lBREMsWUFBWSxDQUFDLFVBQVUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDO29EQUtwQztBQUtEO0lBSEMsWUFBWSxDQUFDLE9BQU8sQ0FBQztJQUNyQixZQUFZLENBQUMsUUFBUSxDQUFDO0lBQ3RCLFlBQVksQ0FBQyxPQUFPLENBQUM7cURBV3JCO0FBMUNVLGtCQUFrQjtJQUg5QixTQUFTLENBQUM7UUFDVCxRQUFRLEVBQUUsY0FBYztLQUN6QixDQUFDO0lBTUcsV0FBQSxJQUFJLEVBQUUsQ0FBQSxFQUFFLFdBQUEsUUFBUSxFQUFFLENBQUE7R0FMVixrQkFBa0IsQ0EyQzlCO1NBM0NZLGtCQUFrQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSG9zdExpc3RlbmVyLCBPcHRpb25hbCwgU2VsZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ3JlZGl0Q2FyZCB9IGZyb20gJy4uL2NyZWRpdC1jYXJkJztcbmltcG9ydCB7IE5nQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnaW5wdXRbY2NDVkNdJyxcbn0pXG5leHBvcnQgY2xhc3MgQ3ZjRm9ybWF0RGlyZWN0aXZlIHtcbiAgcHJpdmF0ZSB0YXJnZXQ6IEhUTUxJbnB1dEVsZW1lbnQ7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBlbDogRWxlbWVudFJlZixcbiAgICBAU2VsZigpIEBPcHRpb25hbCgpIHByaXZhdGUgY29udHJvbDogTmdDb250cm9sLFxuICApIHtcbiAgICB0aGlzLnRhcmdldCA9IHRoaXMuZWwubmF0aXZlRWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB2YWx1ZSB0byB0YXJnZXQgZWxlbWVudCwgb3IgRm9ybUNvbnRyb2wgaWYgZXhpc3RzLlxuICAgKiBAcGFyYW0gdmFsdWUgTmV3IGlucHV0IHZhbHVlLlxuICAgKi9cbiAgcHJpdmF0ZSB1cGRhdGVWYWx1ZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKHRoaXMuY29udHJvbCkge1xuICAgICAgdGhpcy5jb250cm9sLmNvbnRyb2wuc2V0VmFsdWUodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhcmdldC52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2tleXByZXNzJywgWyckZXZlbnQnXSlcbiAgcHVibGljIG9uS2V5cHJlc3MoZTogS2V5Ym9hcmRFdmVudCkge1xuICAgIGlmICghQ3JlZGl0Q2FyZC5yZXN0cmljdE51bWVyaWMoZSkgJiYgIUNyZWRpdENhcmQucmVzdHJpY3RDdmMoZS53aGljaCwgdGhpcy50YXJnZXQpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG5cbiAgQEhvc3RMaXN0ZW5lcigncGFzdGUnKVxuICBASG9zdExpc3RlbmVyKCdjaGFuZ2UnKVxuICBASG9zdExpc3RlbmVyKCdpbnB1dCcpXG4gIHB1YmxpYyByZWZvcm1hdEN2YygpIHtcbiAgICBjb25zdCB2YWwgPSBDcmVkaXRDYXJkLnJlcGxhY2VGdWxsV2lkdGhDaGFycyh0aGlzLnRhcmdldC52YWx1ZSlcbiAgICAgIC5yZXBsYWNlKC9cXEQvZywgJycpXG4gICAgICAuc2xpY2UoMCwgNCk7XG4gICAgY29uc3Qgb2xkVmFsID0gdGhpcy50YXJnZXQudmFsdWU7XG4gICAgaWYgKHZhbCAhPT0gb2xkVmFsKSB7XG4gICAgICB0aGlzLnRhcmdldC5zZWxlY3Rpb25TdGFydCA9IHRoaXMudGFyZ2V0LnNlbGVjdGlvbkVuZCA9IENyZWRpdENhcmQuc2FmZVZhbCh2YWwsIHRoaXMudGFyZ2V0LCAoc2FmZVZhbCA9PiB7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWUoc2FmZVZhbCk7XG4gICAgICB9KSk7XG4gICAgfVxuICB9XG59XG4iXX0=